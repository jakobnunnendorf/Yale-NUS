Some Table Operations
t.select(label) - constructs a new table with just the specified columns
t.drop(label) - constructs a new table in which the specified columns are omitted
t.sort(label) - constructs a new table with rows sorted by the specified column
t.where(label, condition) - constructs a new table with just the rows that match the condition

Table Methods
Creating and extending tables: 
Table().with_column and Table.read_table
Finding the size: num_rows and num_columns
Referring to columns: labels, relabeling, and indices
labels and relabeled; column indices start at 0
Accessing data in a column
column takes a label or index and returns an array
Using array methods to work with data in columns
item, sum, min, max, and so on
Creating new tables containing some of the original columns:
select, drop
Arrays
An array contains a sequence of values
All elements of an array should have the same type
Arithmetic is applied to each element individually
Adding arrays adds elements (if same length!)
A column of a table is an array
Ranges
A range is an array of consecutive numbers
np.arange(end): An array of increasing integers from 0 up to end
np.arange(start, end): An array of increasing integers from start up to end
np.arange(start, end, step): A range with step between consecutive values
The range always includes start but excludes end
Building Tables
Ways to create a table
Table.read_table(filename) - reads a table from a spreadsheet
Table() - an empty table

and… select, where, sort  and so on all create new tables
Table Methods
Creating and extending tables: 
Table().with_column and Table.read_table
Finding the size: num_rows and num_columns
Referring to columns: labels, relabeling, and indices
labels and relabeled; column indices start at 0
Accessing data in a column
column takes a label or index and returns an array
Using array methods to work with data in columns
item, sum, min, max, and so on
Creating new tables containing some of the original columns:
select, drop
Manipulating Rows
t.sort(column) sorts the rows in increasing order
t.sort(column, descending=True)sorts the rows in decreasing order
t.take(row_numbers) keeps the numbered rows
Each row has an index, starting at 0
t.where(column, are.condition) keeps all rows for which a column's value satisfies a condition
t.where(column, value) keeps all rows for which a column's value equals some particular value
Same as t.where(column, are.equal_to(value))

Types of Attributes
All values in a column of a table should be both the same type and be comparable to each other in some way
Numerical — Each value is from a numerical scale
Numerical measurements are ordered
Differences are meaningful
Categorical — Each value is from a fixed inventory
May or may not have an ordering
Categories are the same or different

Plotting Two Numerical Variables
Line graph: plot
Scatter plot : scatter
Summary: charts
Scatter plot: relation between numerical variables

Line graph: sequential data (over time, etc.)

Bar chart: distribution of categorical data

Histogram: distribution of numerical data

Apply
The apply method creates an array by calling a function on every element in one or more input columns
First argument: 		Function to apply
Other arguments: 	The input column(s)
table_name.apply(one_arg_function, 'column_label')
table_name.apply(two_arg_function, 
                 'column_label_for_first_arg',
  'column_label_for_second_arg')
apply called with only a function applies it to each row

Grouping by One Column
The group method aggregates all rows with the same value for a column into a single row in the resulting table.
First argument: 		Which column to group by
Second argument: 	(Optional) How to combine values
len  — number of grouped values (default)
list — list of all grouped values
sum  — total of all grouped values

Lists are Generic Sequences
A list is a sequence of values (just like an array), 	but the values can have different types
[2+3, 'four', Table().with_column('K', [3, 4])]
Lists can be used to create table rows.
If you create a table column from a list, it will be converted to an array automatically
Built into python (you don’t need numpy.)

Grouping By Multiple Columns
The group method can also aggregate all rows that share the combination of values in multiple columns
First argument: 		A list of which columns to group by
Second argument: 	(Optional) How to combine values

Pivot
Cross-classifies according to two categorical variables
Produces a grid of counts or aggregated values
Two required arguments:
First: variable that forms column labels of grid
Second: variable that forms row labels of grid
Two optional arguments (include both or neither)
values=’column_label_to_aggregate’
collect=’function_to_aggregate_with’

Group or Pivot?
Distribution of one categorical variable → .group()
Cross-classification of two or more categorical variables:
One row per combination → .group()
One variable vertically, one horizontally → .pivot()

Important Table Methods
t.select(column, …) or t.drop(column, …)
t.take([row, …]) or t.exclude([row, …])
t.sort(column, descending=False, distinct=False)
t.where(column, are.condition(...)) 
t.apply(function, column, …)
t.group(column) or t.group(column, function)
t.group([column, …]) or t.group([column, …], function)
t.pivot(cols, rows) or t.pivot(cols, rows, vals, function)
t.join(column, other_table, other_table_column)

Important Table Methods
t.select(column, …) or t.drop(column, …)
t.take([row_num, …]) or t.exclude([row_num, …])
t.sort(column, descending=False, distinct=False)
t.where(column, are.condition(...)) 
t.apply(function_name, column, …)
t.group(column) or t.group(column, function_name)
t.group([column, …]) or t.group([column, …], function_name)
t.pivot(cols, rows) or t.pivot(cols, rows, vals, function_name)
t.join(column, other_table, other_table_column)

Random Selection
np.random.choice
Selects uniformly at random
with replacement
from an array,
a specified number of times

np.random.choice(some_array, sample_size)

Appending Arrays
A Longer Array
np.append(array_1, value)
new array with value appended to array_1
value has to be of the same type as elements of array_1
np.append(array_1, array_2)
new array with array_2 appended to array_1
array_2 elements must have the same type as array_1 elements

A Closer Look at where
t.where(array_of_bool_values) 

returns a table 
with only the rows of t for which 
the corresponding bool is True.

Probability Samples
Deterministic sample:
Sampling scheme doesn’t involve chance

Probability sample:
Before the sample is drawn, you have to know the selection probability of every group of people in the population
Not all individuals  have to have equal chance of being selected

Sample of Convenience
Example: sample consists of whoever walks by
Just because you think you’re sampling “at random”, doesn’t mean you are.
If you can’t figure out ahead of time 
what’s the population
what’s the chance of selection, for each group in the population
then you don’t have a random sample

Probability Distribution
Random quantity with various possible values

“Probability distribution”:
All the possible values of the quantity
The probability of each of those values

If you can do the math, you can work out the probability distribution can without ever simulating the random quantity

Empirical Distribution
“Empirical”: based on observations

Observations can be from repetitions of an experiment

“Empirical Distribution”
All observed values
The proportion of times each value appears
Large Random Samples
Law of Averages
If a chance experiment is repeated many times,
independently and under the same conditions,
then the proportion of times that an event occurs
gets closer to the theoretical probability of the event

As you increase the number of rolls of a die, the proportion of times you see the face with five spots gets closer to 1/6

Empirical Distribution of a Sample
If the sample size is large, 

then the empirical distribution of a uniform random sample

resembles the distribution of the population,

with high probability

A Statistic
Terminology
Parameter
A number associated with the population
Statistic
A number calculated from the sample

A statistic can be used as an estimate of a parameter, or to test hypotheses about how the data were generated

Inference
Statistical Inference:
Making conclusions based on data in random samples

Probability Distribution of a Statistic
Values of a statistic vary because random samples vary
“Sampling distribution” or “probability distribution” of the statistic:
All possible values of the statistic,
and all the corresponding probabilities
Can be hard to calculate
Either have to do the math
Or have to generate all possible samples and calculate the statistic based on each sample

Empirical Distribution of a Statistic
Empirical distribution of the statistic:
Based on simulated values of the statistic
Consists of all the observed values of the statistic,
and the proportion of times each value appeared

Good approximation to the probability distribution of the statistic 
if the number of repetitions in the simulation is large

Assessing Models
Models
A model is a set of assumptions about the data

In data science, many models involve assumptions about processes that involve randomness
“Chance models”

Summary of the Method
To assess whether a sample was drawn randomly from a known categorical distribution:
Use TVD as the statistic because it measures the distance between categorical distributions
Sample at random from the population and compute the TVD from the random sample; repeat numerous times
Compare:
Empirical distribution of simulated TVDs
Actual TVD from the sample in the study

Pandas Data Structures:Data Frames, Series, and Indices
Pandas Data Structures
There are three fundamental data structures in pandas:
Data Frame: 2D data tabular data.
Series: 1D data. I usually think of it as columnar data.
Index: A sequence of row labels.

The Relationship Between Data Frames, Series, and Indices
We can think of a Data Frame as a collection of Series that all share the same Index.
Candidate, Party, %, Year, and Result Series all share an index from  0 to 5.

Indices Are Not Necessarily Row Numbers
Indices (a.k.a. row labels) can also:
Be non-numeric.
Have a name, e.g. “State”. 

Indices
The row labels that constitute an index do not have to be unique.
Left: The index values are all unique and numeric, acting as a row number.
Right: The index values are named and non-unique.

Column Names Are Usually Unique!
Column names in Pandas are almost always unique!
Example: Really shouldn’t have two columns named “Candidate”. 

Indexing with The [] Operator
Indexing by Column Names Using [] Operator
Given a dataframe, it is common to extract a Series or a collection of Series. This process is also known as “Column Selection” or sometimes “indexing by column”. 
Column name argument to [] yields Series.
List argument to [] yields a Data Frame.

Indexing by Row Slices Using [] Operator
We can also index by row numbers using the [] operator. 
Numeric slice argument to [] yields rows.
Example: [0:3] yields rows 0 to 2.

Boolean Array Selection 
and Querying
Boolean Array Input
Yet another input type supported by [] is the boolean array.
Boolean Series can be combined using the & operator, allowing filtering of results by multiple criteria. 
isin
The isin function makes it more convenient to find rows that match one of many possible values.

Example: Suppose we want to find “Republican” or “Democratic” candidates. Could use the | operator (| means or), or we can use isin.
The Query Command
The query command provides an alternate way to combine multiple conditions.

Indexing with .loc and .iloc
Sampling with .sample
Loc and iloc
Loc and iloc are alternate ways to index into a DataFrame.
They take a lot of getting used to! Documentation and ideas behind them are quite complex.
I’ll go over common usages (see docs for weirder ones).

Documentation:
loc: https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.loc.html
iloc:  https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.iloc.html
More general docs on indexing and selecting: Link

Loc
Loc does two things:
Access values by labels.
Access values using a boolean array (a la Boolean Array Selection).

Loc with Lists
The most basic use of loc is to provide a list of row and column labels, which returns a DataFrame.

Loc with Lists
The most basic use of loc is to provide a list of row and column labels, which returns a DataFrame.

Loc with Slices
Loc is also commonly used with slices. 
Slicing works with all label types, not just numeric labels.
Slices with loc are inclusive, not exclusive.

Loc with Slices
Loc is also commonly used with slices. 
Slicing works with all label types, not just numeric labels.
Slices with loc are inclusive, not exclusive.

Loc with Single Values for Column Label
If we provide only a single label as column argument, we get a Series.

Loc with Single Values for Column Label
As before with the [] operator, if we provide a list of only one label as an argument, we get back a dataframe.

Loc with Single Values for Row Label
If we provide only a single row label, we get a Series.
Such a series represents a ROW not a column!
The index of this Series is the names of the columns from the data frame.
Putting the single row label in a list yields a dataframe version.

Loc Supports Boolean Arrays
Loc supports Boolean Arrays exactly as you’d expect.

iloc: Integer-Based Indexing for Selection by Position
In contrast to loc, iloc doesn’t think about labels at all. Instead, it returns the items that appear in the numerical positions specified.

Advantages of loc:
Harder to make mistakes.
Easier to read code.
Not vulnerable to changes to the ordering of rows/cols in raw data files.
Nonetheless, iloc can be more convenient. Use iloc judiciously. 

Annoying Question Challenge 
Which of the following pandas statements returns a DataFrame of the first 3 Candidate names only for candidates that won with more than 50% of the vote.
elections.iloc[[0, 3, 5], [0, 3]]
elections.loc[[0, 3, 5], ["Candidate":"Year"]
elections.loc[elections["%"] > 50, ["Candidate", "Year"]].head(3)
elections.loc[elections["%"] > 50, ["Candidate", "Year"]].iloc[0:2, :]

Annoying Question Challenge
Which of the following pandas statements returns a DataFrame of the first 3 Candidate names only for candidates that won with more than 50% of the vote.
elections.iloc[[0, 3, 5], [0, 3]]
elections.loc[[0, 3, 5], ["Candidate":"Year"]
elections.loc[elections["%"] > 50, ["Candidate", "Year"]].head(3)
elections.loc[elections["%"] > 50, ["Candidate", "Year"]].iloc[0:2, :]

Sample
If you want a DataFrame consisting of a random selection of rows, you can use the sample method.
By default, it is without replacement. Use replace=true for replacement.
Naturally, can be chained with our selection operators [], loc, iloc.

Handy Properties and Utility Functions for Series and DataFrames
Numpy Operations
Pandas Series and DataFrames support a large number of operations, including mathematical operations so long as the data is numerical.
head, size, shape, and describe 
head: Displays only the top few rows.
size: Gives the total number of data points.
shape: Gives the size of the data in rows and columns.
describe: Provides a summary of the data.

 
index and columns
index: Returns the index (a.k.a. row labels).
columns: Returns the labels for the columns.

The sort_values Method
One incredibly useful method for DataFrames is sort_values, which creates a copy of a DataFrame sorted by a specific column.

The sort_values Method
We can also use sort_values on a Series, which returns a copy with with the values in order.

The value_counts Method
Series also has the function value_counts, which creates a new Series showing the counts of every value.

The unique Method
Another handy method for Series  is unique, which returns all unique values as an array.
